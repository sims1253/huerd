% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate_palette.R
\name{generate_palette}
\alias{generate_palette}
\title{Generate Optimal Color Palette using Pure Minimax Optimization}
\usage{
generate_palette(
  n,
  include_colors = NULL,
  initialization = c("k-means++", "harmony"),
  init_lightness_bounds = c(0.2, 0.9),
  init_hcl_bounds = list(C = c(40, 80), L = c(50, 80)),
  fixed_aesthetic_influence = 0.75,
  aesthetic_init_config = NULL,
  max_iterations = 1000,
  return_metrics = TRUE,
  progress = interactive(),
  weights = NULL,
  optimizer = "nloptr_cobyla"
)
}
\arguments{
\item{n}{Integer. Total number of colors in the palette.}

\item{include_colors}{Character vector. Hex colors that must be included
in the palette unchanged. Default is NULL.}

\item{initialization}{Character. Initialization method for free colors:
"k-means++" or "harmony". Default is "k-means++".}

\item{init_lightness_bounds}{Numeric vector of length 2. For k-means++ initialization,
target lightness (L in OKLAB) range for initial candidates. Default \code{c(0.2, 0.9)}.}

\item{init_hcl_bounds}{List. For harmony-based initialization, target
\code{C} (Chroma) and \code{L} (Luminance) ranges for initial HCL colors.
Default \code{list(C = c(40, 80), L = c(50, 80))}.}

\item{fixed_aesthetic_influence}{Numeric, 0 to 1. If \code{include_colors} are provided,
controls how strongly their aesthetic properties influence the initialization
for free colors. 0 = no influence, 1 = strong influence. Default is 0.75.}

\item{aesthetic_init_config}{List. Advanced configuration for aesthetic initialization.
Use \code{NULL} (default) for built-in defaults.}

\item{max_iterations}{Integer. Maximum optimization iterations. Default is 1000.}

\item{return_metrics}{Logical. Whether to return evaluation metrics as
attributes. Default is TRUE.}

\item{progress}{Logical. Show progress messages. Default is \code{interactive()}.}

\item{weights}{Named numeric vector. Weights for multi-objective optimization.
Supports: \code{c(distance = 1)} for discrete distance optimization (default),
\code{c(smooth_repulsion = 1)} for smooth repulsion objective using inverse squared
distances, or \code{c(smooth_logsumexp = 1)} for smooth log-sum-exp objective.
Default is NULL (equivalent to pure distance optimization).}

\item{optimizer}{Character. Optimization algorithm to use. Currently supported:
"nloptr_cobyla" (default) for deterministic optimization with constraint handling,
"sann" for stochastic simulated annealing (excellent quality but not perfectly
reproducible without a seed), "nlopt_direct" for deterministic global optimization
using the DIRECT algorithm (best choice for scientific reproducibility and high
quality, though may be slower), "nlopt_neldermead" for derivative-free local
optimization using the Nelder-Mead simplex algorithm (good alternative to COBYLA
for robust local optimization), "nlopt_lbfgs" for gradient-based L-BFGS optimization
(fastest convergence for smooth objectives, requires smooth weights). The framework
is designed to easily support additional optimizers in future versions.}
}
\value{
A character vector of hex colors with class \code{huerd_palette}, automatically
sorted by brightness (lightness). If \code{return_metrics = TRUE}, includes evaluation
metrics as attributes.
}
\description{
Creates a scientifically-grounded color palette that maximizes the minimum
perceptual distance between any two colors using pure minimax optimization in
the OKLAB color space. Colors are automatically sorted by brightness and can
include fixed brand colors.
}
\details{
This function implements pure minimax optimization to create color palettes with
maximum worst-case perceptual distinguishability. The approach is scientifically
grounded and focuses on a single, clear objective.

The process:
\enumerate{
\item Initialize free colors using k-means++ or harmony-based methods
\item Optimize using box-constrained nloptr to maximize minimum perceptual distance
\item Sort final palette by OKLAB lightness for intuitive ordering
\item Apply gamut compensation during brightness sorting
}

The pure minimax approach ensures optimal categorical color palettes without
complex multi-objective trade-offs. Quality can be assessed using \code{evaluate_palette()}
and visualized with \code{plot_palette_analysis()}.
}
\section{Performance Tips}{

\itemize{
\item For low performance ratios, try increasing \code{max_iterations}
\item Use \code{progress = TRUE} to monitor optimization convergence
\item Include 2-3 fixed colors maximum for best optimization
\item Use diagnostic dashboard \code{plot_palette_analysis()} for analysis
}
}

\examples{
# Simple optimal palette
palette <- generate_palette(5, progress = FALSE)
print(palette)

# Brand-constrained palette
brand_palette <- generate_palette(
  n = 6,
  include_colors = c("#4A6B8A", "#E5A04C"),
  progress = FALSE
)

# Using specific optimizer (deterministic)
optimizer_palette <- generate_palette(
  n = 4,
  optimizer = "nloptr_cobyla",
  progress = FALSE
)

# Using simulated annealing (stochastic, excellent quality)
set.seed(42)  # For reproducibility
sann_palette <- generate_palette(
  n = 4,
  optimizer = "sann",
  progress = FALSE
)

# Using DIRECT algorithm (deterministic global, best for scientific reproducibility)
direct_palette <- generate_palette(
  n = 4,
  optimizer = "nlopt_direct",
  progress = FALSE
)

# Using Nelder-Mead algorithm (derivative-free local, good alternative to COBYLA)
neldermead_palette <- generate_palette(
  n = 4,
  optimizer = "nlopt_neldermead",
  progress = FALSE
)

# Using smooth optimization with L-BFGS (fastest for large palettes)
smooth_palette <- generate_palette(
  n = 8,
  weights = c(smooth_repulsion = 1),
  optimizer = "nlopt_lbfgs",
  progress = FALSE
)

# Using alternative smooth objective
logsumexp_palette <- generate_palette(
  n = 6,
  weights = c(smooth_logsumexp = 1),
  optimizer = "nlopt_lbfgs",
  progress = FALSE
)

# Evaluate quality
evaluation <- evaluate_palette(brand_palette)
cat("Min distance:", evaluation$distances$min, "\n")
cat("Performance:", evaluation$distances$performance_ratio * 100, "\%\n")

# Comprehensive analysis
plot_palette_analysis(brand_palette)

}
